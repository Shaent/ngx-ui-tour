(self["webpackChunkngx_ui_tour"] = self["webpackChunkngx_ui_tour"] || []).push([["default-node_modules_rxjs__esm2015_internal_operators_delay_js-dist_ngx-ui-tour-core___ivy_ng-e0207a"],{

/***/ 945:
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/_esm2015/internal/observable/interval.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interval": function() { return /* binding */ interval; }
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Observable */ 9165);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/async */ 3637);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isNumeric */ 6561);



function interval(period = 0, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async) {
    if (!(0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable(subscriber => {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));
        return subscriber;
    });
}
function dispatch(state) {
    const { subscriber, counter, period } = state;
    subscriber.next(counter);
    this.schedule({ subscriber, counter: counter + 1, period }, period);
}
//# sourceMappingURL=interval.js.map

/***/ }),

/***/ 8984:
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/_esm2015/internal/operators/debounce.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": function() { return /* binding */ debounce; }
/* harmony export */ });
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../innerSubscribe */ 5345);

function debounce(durationSelector) {
    return (source) => source.lift(new DebounceOperator(durationSelector));
}
class DebounceOperator {
    constructor(durationSelector) {
        this.durationSelector = durationSelector;
    }
    call(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    }
}
class DebounceSubscriber extends _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__.SimpleOuterSubscriber {
    constructor(destination, durationSelector) {
        super(destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
    }
    _next(value) {
        try {
            const result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    }
    _complete() {
        this.emitValue();
        this.destination.complete();
    }
    _tryNext(value, duration) {
        let subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__.innerSubscribe)(duration, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__.SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    }
    notifyNext() {
        this.emitValue();
    }
    notifyComplete() {
        this.emitValue();
    }
    emitValue() {
        if (this.hasValue) {
            const value = this.value;
            const subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = undefined;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = undefined;
            this.hasValue = false;
            super._next(value);
        }
    }
}
//# sourceMappingURL=debounce.js.map

/***/ }),

/***/ 5792:
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/_esm2015/internal/operators/delay.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delay": function() { return /* binding */ delay; }
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/async */ 3637);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/isDate */ 4106);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Subscriber */ 7393);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Notification */ 3098);




function delay(delay, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async) {
    const absoluteDelay = (0,_util_isDate__WEBPACK_IMPORTED_MODULE_1__.isDate)(delay);
    const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return (source) => source.lift(new DelayOperator(delayFor, scheduler));
}
class DelayOperator {
    constructor(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    call(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    }
}
class DelaySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber {
    constructor(destination, delay, scheduler) {
        super(destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    static dispatch(state) {
        const source = state.source;
        const queue = source.queue;
        const scheduler = state.scheduler;
        const destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            const delay = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    }
    _schedule(scheduler) {
        this.active = true;
        const destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    }
    scheduleNotification(notification) {
        if (this.errored === true) {
            return;
        }
        const scheduler = this.scheduler;
        const message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    }
    _next(value) {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__.Notification.createNext(value));
    }
    _error(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    }
    _complete() {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__.Notification.createComplete());
        this.unsubscribe();
    }
}
class DelayMessage {
    constructor(time, notification) {
        this.time = time;
        this.notification = notification;
    }
}
//# sourceMappingURL=delay.js.map

/***/ }),

/***/ 4106:
/*!************************************************************!*\
  !*** ./node_modules/rxjs/_esm2015/internal/util/isDate.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isDate": function() { return /* binding */ isDate; }
/* harmony export */ });
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map

/***/ }),

/***/ 5092:
/*!*************************************************************************!*\
  !*** ./dist/ngx-ui-tour-core/__ivy_ngcc__/fesm2015/ngx-ui-tour-core.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ElementSides": function() { return /* binding */ ElementSides; },
/* harmony export */   "ScrollingUtil": function() { return /* binding */ ScrollingUtil; },
/* harmony export */   "TourBackdropService": function() { return /* binding */ TourBackdropService; },
/* harmony export */   "TourHotkeyListenerComponent": function() { return /* binding */ TourHotkeyListenerComponent; },
/* harmony export */   "TourModule": function() { return /* binding */ TourModule; },
/* harmony export */   "TourService": function() { return /* binding */ TourService; },
/* harmony export */   "TourState": function() { return /* binding */ TourState; },
/* harmony export */   "isInViewport": function() { return /* binding */ isInViewport; }
/* harmony export */ });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/common */ 8583);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/core */ 7716);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/router */ 9895);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 9765);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 6682);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ 9412);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ 2759);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs */ 945);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ 8002);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 5435);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ 8049);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ 8984);









const _c0 = ["*"];
var TourState;
(function (TourState) {
    TourState[TourState["OFF"] = 0] = "OFF";
    TourState[TourState["ON"] = 1] = "ON";
    TourState[TourState["PAUSED"] = 2] = "PAUSED";
})(TourState || (TourState = {}));
class TourService {
    constructor(router) {
        this.router = router;
        this.stepShow$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.stepHide$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.initialize$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.start$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.end$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.pause$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.resume$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.startWaiting$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.stopWaiting$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.anchorRegister$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.anchorUnregister$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
        this.events$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.merge)(this.stepShow$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'stepShow', value }))), this.stepHide$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'stepHide', value }))), this.initialize$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'initialize', value }))), this.start$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'start', value }))), this.end$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'end', value }))), this.pause$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'pause', value }))), this.resume$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({ name: 'resume', value }))), this.anchorRegister$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({
            name: 'anchorRegister',
            value
        }))), this.anchorUnregister$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(value => ({
            name: 'anchorUnregister',
            value
        }))));
        this.steps = [];
        this.anchors = {};
        this.status = TourState.OFF;
        this.isHotKeysEnabled = true;
    }
    initialize(steps, stepDefaults) {
        if (steps && steps.length > 0) {
            this.status = TourState.OFF;
            this.steps = steps.map(step => Object.assign({}, stepDefaults, step));
            this.initialize$.next(this.steps);
        }
    }
    disableHotkeys() {
        this.isHotKeysEnabled = false;
    }
    enableHotkeys() {
        this.isHotKeysEnabled = true;
    }
    start() {
        this.startAt(0);
    }
    startAt(stepId) {
        this.status = TourState.ON;
        this.goToStep(this.loadStep(stepId));
        this.start$.next();
        this.router.events
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(event => event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_4__.NavigationStart), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.first)())
            .subscribe(() => {
            if (this.currentStep && this.currentStep.hasOwnProperty('route')) {
                this.hideStep(this.currentStep);
            }
        });
    }
    end() {
        this.status = TourState.OFF;
        this.hideStep(this.currentStep);
        this.currentStep = undefined;
        this.end$.next();
    }
    pause() {
        this.status = TourState.PAUSED;
        this.hideStep(this.currentStep);
        this.pause$.next();
    }
    resume() {
        this.status = TourState.ON;
        this.showStep(this.currentStep);
        this.resume$.next();
    }
    toggle(pause) {
        if (pause) {
            if (this.currentStep) {
                this.pause();
            }
            else {
                this.resume();
            }
        }
        else {
            if (this.currentStep) {
                this.end();
            }
            else {
                this.start();
            }
        }
    }
    next() {
        if (this.hasNext(this.currentStep)) {
            this.goToStep(this.loadStep(this.currentStep.nextStep || this.steps.indexOf(this.currentStep) + 1));
        }
    }
    hasNext(step) {
        if (!step) {
            console.warn('Can\'t get next step. No currentStep.');
            return false;
        }
        return (step.nextStep !== undefined ||
            this.steps.indexOf(step) < this.steps.length - 1);
    }
    prev() {
        if (this.hasPrev(this.currentStep)) {
            this.goToStep(this.loadStep(this.currentStep.prevStep || this.steps.indexOf(this.currentStep) - 1));
        }
    }
    hasPrev(step) {
        if (!step) {
            console.warn('Can\'t get previous step. No currentStep.');
            return false;
        }
        return step.prevStep !== undefined || this.steps.indexOf(step) > 0;
    }
    goto(stepId) {
        this.goToStep(this.loadStep(stepId));
    }
    register(anchorId, anchor) {
        if (!anchorId) {
            return;
        }
        if (this.anchors[anchorId]) {
            throw new Error('anchorId ' + anchorId + ' already registered!');
        }
        this.anchors[anchorId] = anchor;
        this.anchorRegister$.next(anchorId);
    }
    unregister(anchorId) {
        if (!anchorId) {
            return;
        }
        delete this.anchors[anchorId];
        this.anchorUnregister$.next(anchorId);
    }
    getStatus() {
        return this.status;
    }
    isHotkeysEnabled() {
        return this.isHotKeysEnabled;
    }
    goToStep(step) {
        if (!step) {
            console.warn('Can\'t go to non-existent step');
            this.end();
            return;
        }
        if (this.currentStep) {
            this.hideStep(this.currentStep);
        }
        let navigatePromise = new Promise(resolve => resolve(true));
        if (typeof step.route === 'string') {
            navigatePromise = this.router.navigateByUrl(step.route);
        }
        else if (Array.isArray(step.route)) {
            navigatePromise = this.router.navigate(step.route);
        }
        navigatePromise.then(navigated => {
            if (navigated !== false && !step.waitFor) {
                setTimeout(() => this.setCurrentStep(step));
            }
            else if (navigated !== false) {
                this.wait(step);
            }
        });
    }
    wait(step) {
        const waitFor$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.from)(step.waitFor);
        this.startWaiting$.next(step);
        waitFor$
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.first)())
            .subscribe(() => {
            setTimeout(() => this.setCurrentStep(step));
            this.stopWaiting$.next(step);
        });
    }
    loadStep(stepId) {
        if (typeof stepId === 'number') {
            return this.steps[stepId];
        }
        else {
            return this.steps.find(step => step.stepId === stepId);
        }
    }
    setCurrentStep(step) {
        this.currentStep = step;
        this.showStep(this.currentStep);
        this.router.events
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(event => event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_4__.NavigationStart), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.first)())
            .subscribe(() => {
            if (this.currentStep && this.currentStep.hasOwnProperty('route')) {
                this.hideStep(this.currentStep);
            }
        });
    }
    showStep(step) {
        const anchor = this.anchors[step && step.anchorId];
        if (!anchor) {
            if (step.isAsync) {
                this.startWaiting$.next(step);
                this.anchorRegister$
                    .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(anchorId => anchorId === step.anchorId), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.first)())
                    .subscribe(() => {
                    setTimeout(() => this.showStep(step));
                    this.stopWaiting$.next(step);
                });
                return;
            }
            console.warn('Can\'t attach to unregistered anchor with id ' + step.anchorId);
            this.end();
            return;
        }
        anchor.showTourStep(step);
        this.stepShow$.next(step);
    }
    hideStep(step) {
        const anchor = this.anchors[step && step.anchorId];
        if (!anchor) {
            return;
        }
        anchor.hideTourStep();
        this.stepHide$.next(step);
    }
}
TourService.ɵfac = function TourService_Factory(t) { return new (t || TourService)(_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵinject"](_angular_router__WEBPACK_IMPORTED_MODULE_4__.Router)); };
TourService.ɵprov = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineInjectable"]({ token: TourService, factory: TourService.ɵfac });
TourService.ctorParameters = () => [
    { type: _angular_router__WEBPACK_IMPORTED_MODULE_4__.Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵsetClassMetadata"](TourService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable
    }], function () { return [{ type: _angular_router__WEBPACK_IMPORTED_MODULE_4__.Router }]; }, null); })();

class TourHotkeyListenerComponent {
    constructor(tourService) {
        this.tourService = tourService;
    }
    /**
     * Configures hot keys for controlling the tour with the keyboard
     */
    onEscapeKey() {
        if (this.tourService.getStatus() === TourState.ON &&
            this.tourService.isHotkeysEnabled()) {
            this.tourService.end();
        }
    }
    onArrowRightKey() {
        if (this.tourService.getStatus() === TourState.ON &&
            this.tourService.hasNext(this.tourService.currentStep) &&
            this.tourService.isHotkeysEnabled()) {
            this.tourService.next();
        }
    }
    onArrowLeftKey() {
        if (this.tourService.getStatus() === TourState.ON &&
            this.tourService.hasPrev(this.tourService.currentStep) &&
            this.tourService.isHotkeysEnabled()) {
            this.tourService.prev();
        }
    }
}
TourHotkeyListenerComponent.ɵfac = function TourHotkeyListenerComponent_Factory(t) { return new (t || TourHotkeyListenerComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdirectiveInject"](TourService)); };
TourHotkeyListenerComponent.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineComponent"]({ type: TourHotkeyListenerComponent, selectors: [["tour-hotkey-listener"]], hostBindings: function TourHotkeyListenerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵlistener"]("keydown.Escape", function TourHotkeyListenerComponent_keydown_Escape_HostBindingHandler() { return ctx.onEscapeKey(); }, false, _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵresolveWindow"])("keydown.ArrowRight", function TourHotkeyListenerComponent_keydown_ArrowRight_HostBindingHandler() { return ctx.onArrowRightKey(); }, false, _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵresolveWindow"])("keydown.ArrowLeft", function TourHotkeyListenerComponent_keydown_ArrowLeft_HostBindingHandler() { return ctx.onArrowLeftKey(); }, false, _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵresolveWindow"]);
    } }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function TourHotkeyListenerComponent_Template(rf, ctx) { if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵprojection"](0);
    } }, encapsulation: 2 });
TourHotkeyListenerComponent.ctorParameters = () => [
    { type: TourService }
];
TourHotkeyListenerComponent.propDecorators = {
    onEscapeKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener, args: ['window:keydown.Escape',] }],
    onArrowRightKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener, args: ['window:keydown.ArrowRight',] }],
    onArrowLeftKey: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener, args: ['window:keydown.ArrowLeft',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵsetClassMetadata"](TourHotkeyListenerComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Component,
        args: [{
                selector: 'tour-hotkey-listener',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: TourService }]; }, { 
    /**
     * Configures hot keys for controlling the tour with the keyboard
     */
    onEscapeKey: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener,
            args: ['window:keydown.Escape']
        }], onArrowRightKey: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener,
            args: ['window:keydown.ArrowRight']
        }], onArrowLeftKey: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.HostListener,
            args: ['window:keydown.ArrowLeft']
        }] }); })();

var ElementSides;
(function (ElementSides) {
    ElementSides[ElementSides["Top"] = 0] = "Top";
    ElementSides[ElementSides["Bottom"] = 1] = "Bottom";
    ElementSides[ElementSides["All"] = 2] = "All";
})(ElementSides || (ElementSides = {}));
function isInViewport(htlmElement, sidesToCheck = ElementSides.All) {
    const viewportWidth = window.innerWidth, viewportHeight = window.innerHeight, boundingRectangle = htlmElement.getBoundingClientRect(), areCornersInViewport = boundingRectangle.left >= 0 && boundingRectangle.right <= viewportWidth, isTopInViewport = boundingRectangle.top >= 0, isBottomInViewport = boundingRectangle.bottom <= viewportHeight;
    if (sidesToCheck === ElementSides.Top) {
        return isTopInViewport && areCornersInViewport;
    }
    if (sidesToCheck === ElementSides.Bottom) {
        return isBottomInViewport && areCornersInViewport;
    }
    return isTopInViewport && isBottomInViewport && areCornersInViewport;
}

class ScrollingUtil {
    static ensureVisible(htmlElement) {
        if (!isInViewport(htmlElement, ElementSides.Bottom)) {
            htmlElement.scrollIntoView(false);
        }
        else if (!isInViewport(htmlElement, ElementSides.Top)) {
            htmlElement.scrollIntoView(true);
        }
    }
}

class TourBackdropService {
    constructor(rendererFactory) {
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    show(targetElement) {
        const boundingRect = targetElement.nativeElement.getBoundingClientRect();
        if (!this.backdropElement) {
            this.createBackdrop();
            this.subscribeToWindowResizeEvent();
        }
        this.targetHtmlElement = targetElement.nativeElement;
        this.setBackdropElStyles(boundingRect);
    }
    createBackdrop() {
        this.createBackdropBaseElement();
        this.createBackdropElement();
    }
    createBackdropBaseElement() {
        const baseElStyles = {
            position: 'fixed',
            height: '100%',
            width: '100%',
            top: '0',
            left: '0',
            zIndex: '100'
        };
        this.backdropBaseElement = this.renderer.createElement('div');
        this.applyStyles(baseElStyles, this.backdropBaseElement);
        this.renderer.appendChild(document.body, this.backdropBaseElement);
    }
    createBackdropElement() {
        this.backdropElement = this.renderer.createElement('div');
        this.renderer.addClass(this.backdropElement, 'ngx-ui-tour_backdrop');
        this.renderer.appendChild(document.body, this.backdropElement);
    }
    subscribeToWindowResizeEvent() {
        const resizeObservable$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_8__.fromEvent)(window, 'resize');
        this.windowResizeSubscription$ = resizeObservable$
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.debounce)(() => (0,rxjs__WEBPACK_IMPORTED_MODULE_10__.interval)(10)))
            .subscribe(() => {
            const boundingRect = this.targetHtmlElement.getBoundingClientRect();
            this.setBackdropElStyles(boundingRect);
            ScrollingUtil.ensureVisible(this.targetHtmlElement);
        });
    }
    close() {
        if (this.backdropElement) {
            this.removeBackdropElement();
            this.windowResizeSubscription$.unsubscribe();
        }
    }
    removeBackdropElement() {
        this.renderer.removeChild(document.body, this.backdropBaseElement);
        this.renderer.removeChild(document.body, this.backdropElement);
        this.backdropBaseElement = null;
        this.backdropElement = null;
    }
    setBackdropElStyles(boundingRect) {
        var _a, _b;
        const scrollX = (_a = window.scrollX) !== null && _a !== void 0 ? _a : window.pageXOffset, scrollY = (_b = window.scrollY) !== null && _b !== void 0 ? _b : window.pageYOffset, styles = {
            position: 'absolute',
            width: `${boundingRect.width}px`,
            height: `${boundingRect.height}px`,
            top: `${boundingRect.top + scrollY}px`,
            left: `${boundingRect.left + scrollX}px`,
            boxShadow: '0 0 0 9999px rgba(0, 0, 0, 0.7)',
            zIndex: '101'
        };
        this.applyStyles(styles, this.backdropElement);
    }
    applyStyles(styles, element) {
        for (const name of Object.keys(styles)) {
            this.renderer.setStyle(element, name, styles[name]);
        }
    }
}
TourBackdropService.ɵfac = function TourBackdropService_Factory(t) { return new (t || TourBackdropService)(_angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_7__.RendererFactory2)); };
TourBackdropService.ɵprov = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineInjectable"]({ token: TourBackdropService, factory: TourBackdropService.ɵfac });
TourBackdropService.ctorParameters = () => [
    { type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.RendererFactory2 }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵsetClassMetadata"](TourBackdropService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.Injectable
    }], function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.RendererFactory2 }]; }, null); })();

class TourModule {
    static forRoot() {
        return {
            ngModule: TourModule,
            providers: [
                TourService,
                TourBackdropService
            ],
        };
    }
}
TourModule.ɵfac = function TourModule_Factory(t) { return new (t || TourModule)(); };
TourModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineNgModule"]({ type: TourModule });
TourModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵdefineInjector"]({ imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_11__.CommonModule, _angular_router__WEBPACK_IMPORTED_MODULE_4__.RouterModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵsetClassMetadata"](TourModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_7__.NgModule,
        args: [{
                declarations: [TourHotkeyListenerComponent],
                exports: [TourHotkeyListenerComponent],
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_11__.CommonModule, _angular_router__WEBPACK_IMPORTED_MODULE_4__.RouterModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_7__["ɵɵsetNgModuleScope"](TourModule, { declarations: function () { return [TourHotkeyListenerComponent]; }, imports: function () { return [_angular_common__WEBPACK_IMPORTED_MODULE_11__.CommonModule, _angular_router__WEBPACK_IMPORTED_MODULE_4__.RouterModule]; }, exports: function () { return [TourHotkeyListenerComponent]; } }); })();

/*
 * Public API Surface of ngx-ui-tour-core
 */

/**
 * Generated bundle index. Do not edit.
 */





/***/ })

}]);
//# sourceMappingURL=default-node_modules_rxjs__esm2015_internal_operators_delay_js-dist_ngx-ui-tour-core___ivy_ng-e0207a-es2015.js.map